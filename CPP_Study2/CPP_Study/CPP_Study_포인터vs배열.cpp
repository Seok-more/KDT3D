// CPP_Study.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
// 프로그램 실행: <Ctrl+F5> 또는 [디버그] > [디버깅하지 않고 시작] 메뉴
// 프로그램 디버그: <F5> 키 또는 [디버그] > [디버깅 시작] 메뉴
// 시작을 위한 팁: 
//   1. [솔루션 탐색기] 창을 사용하여 파일을 추가/관리합니다.
//   2. [팀 탐색기] 창을 사용하여 소스 제어에 연결합니다.
//   3. [출력] 창을 사용하여 빌드 출력 및 기타 메시지를 확인합니다.
//   4. [오류 목록] 창을 사용하여 오류를 봅니다.
//   5. [프로젝트] > [새 항목 추가]로 이동하여 새 코드 파일을 만들거나, [프로젝트] > [기존 항목 추가]로 이동하여 기존 코드 파일을 프로젝트에 추가합니다.
//   6. 나중에 이 프로젝트를 다시 열려면 [파일] > [열기] > [프로젝트]로 이동하고 .sln 파일을 선택합니다.
#include <iostream>
using namespace std;

// 포인터 vs 배열

#pragma region Struct

#pragma endregion


void Test(int a)
{
	a++;
}


// 배열을 함수 인자로 넘기면, 컴파일러가 알아서 포인터로 치환함(char[] -> char*)
// 즉 배열의 내용을 전부 넘긴 것이 아닌 포인터만 넘긴 것이다.
void Test2(char a[])
{
	a[0] = 'x';
}


int main()
{
	// 문자열 = 문자 배열
	//"Hello World"; // const char형 배열, 마우스가 갖다대보면 12개임, \0도 들어있음


	// 포인터와 배열의 차이
	// 포인터 : [ 주소를 담는 바구니 ]
	// 배열 : 바구니 모음[][][][], 그 자체로 같은 데이터 끼리 붙어있는 바구니 모음

	// test1[ 주소a ] << 8바이트
	// .rodata (주소a)[H][e][l][l][o][ ][W][o][r][l][d][\0]
	// 데이터의 수가 늘어난다고 해도 주소를 담은 바구니는 8바이트로 고정
	const char* test1 = "Hello World";
	// test1[0] = 'R'; 포인터가 주소만 갖고있으므로 값을 바꿀수는 없음 const라서 수정불가가 아님

	// [H][e][l][l][o][ ][W][o][r][l][d][\0] 여기에서 아래로
	// [H][e][l][l] / [o][ ][W][o] / [r][l][d][\0] 4바이트씩 복사해준것 << 12바이트
	// 데이터의 수가 늘어나면 그만큼 배열의 바이트가 늘어남
	// test2 = 시작주소,  test2[ 주소 ]라는 바구니가 만들어진것이 아님!
	// - [배열 이름]은 '바구니 모음'의 [시작 주소]
	char test2[] = "Hello World";
	test2[0] = 'R';


	// 배열을 함수의 인자로 넘긴다면?

	// 그냥 변수가 함수의 인자인 경우, 복사가 되고 원본은 접근할 수 없음
	int a = 0;
	// [매개변수][RET][지역변수(a = 0)] / [매개변수(a++)][RET][지역변수] 
	//				여기를						이곳으로 복사해서 ++하고
	//											이곳의 작업이 끝나면 팝하고
	//				여기를 다시 반환
	Test(a); // a++; 
	cout << a << endl; // 0이 출력됨 a의 값을 temp에 복사해 놓고 temp에 ++ 한다음에 다시 a의 값을 반환하면 당연히 0임


	// test2가 바뀜
	// 배열을 인자로 넘길때는, 배열에 있는 모든 데이터를 복사하는 것이 아닌, 배열의 시작 주소를 넘겨서 원본에 접근하도록함
	// [!] 배열을 함수 인자로 넘기면, 컴파일러가 알아서 포인터로 치환함(char[] -> char*)
	Test2(test2);
	cout << test2 << endl;


	// 요약
	// 포인터 vs 배열
	// - 배열의 이름 자체가 포인터로 변환되고, 시작 주소를 의미하되
	// - 메모리 상에서 차이가난다.
	//	= 포인터는 그 자체로 별도의 바구니가 생성, 그 바구니안에 주소가 있음, test1[ 주소a ] << 8바이트
	//	= 배열은 이름 자체가 주소일 뿐, 실제는 배열의 N바이트 그 자체가 생성됨
	// 배열을 함수의 인자로 넘기면 포인터로 넘기게 된다.

	return 0;
}


