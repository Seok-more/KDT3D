// CPP_Study.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
// 프로그램 실행: <Ctrl+F5> 또는 [디버그] > [디버깅하지 않고 시작] 메뉴
// 프로그램 디버그: <F5> 키 또는 [디버그] > [디버깅 시작] 메뉴
// 시작을 위한 팁: 
//   1. [솔루션 탐색기] 창을 사용하여 파일을 추가/관리합니다.
//   2. [팀 탐색기] 창을 사용하여 소스 제어에 연결합니다.
//   3. [출력] 창을 사용하여 빌드 출력 및 기타 메시지를 확인합니다.
//   4. [오류 목록] 창을 사용하여 오류를 봅니다.
//   5. [프로젝트] > [새 항목 추가]로 이동하여 새 코드 파일을 만들거나, [프로젝트] > [기존 항목 추가]로 이동하여 기존 코드 파일을 프로젝트에 추가합니다.
//   6. 나중에 이 프로젝트를 다시 열려면 [파일] > [열기] > [프로젝트]로 이동하고 .sln 파일을 선택합니다.
#include <iostream>
using namespace std;

// 포인터2

void SetHp(int* hp)
{
	*hp = 100;
}


//[매개변수][RET][지역변수]

int main()
{

	int hp = 1;
	//SetHp(hp); //[매개변수][RET][지역변수(hp 1)] --> SetHp로 이동: [매개변수(hp 100)][RET][지역변수] : 노답
	SetHp(&hp); //[매개변수][RET][지역변수(hp 1)] --> SetHp로 이동, hp의 주소의 값을 갖고와요
	// [매개변수(hp의 주소에 있는 값 1)][RET][지역변수]
   // --> [매개변수][RET][지역변수(hp 100)]




// 지끔까지 사용한 방식
// number라는 이름의 4바이트 정수 타입의 바구니를 만든다.
// number라는 변수 스택 메모리에 할당
// number라는 바구니에 1이라는 숫자를 넣어라는 의미
// 즉, 스택 메모리에 있는 특정 주소(number 바구니)에 우리가 원하는 값을 넣은 셈
// 비유하자면 number는 메모리에 이름을 붙인 것
// 단점 : 원본 수정
	int number = 1;

	// TYPE* 변수이름;
	// - TYPE : 변수 타입
	// - * : 포탈을 연다.
	// [주소를 저장하는 바구니]* [변수이름];
	// 포인터는 4byte(32bit x86환경)/ 대부분 8byte(64bit x64환경) 고정 크기

	int* ptr = &number; // ptr에 number의 주소를 저장, &표시는 주소를 의미함, 어셈블리 메모리 주소에 &number 검색해서 찾아볼 수 있음

	// 추가 문법 : [주소를 저장한느 바구니]가 가리키는 주소로 가서 작업해라

	int value1 = *ptr; // *변수이름 = 값; ptr이 저장하고있는 주소에 있는 값을 갖고 와라 value1 = 1
	*ptr = 2; // ptr이 저장하고 있는 주소에 가서 값을 2로 바꿔라 number = 2

	cout << number << endl; // 2의 값이 나온다.

	// TYPE의 존재 이유
	// 어짜피 주소 값이고 4/8바이트 고정 크기인데 왜 선언함?
	// 주소에 가면 있는 데이터가 어떤 것인지 알려줌, TYPE에서 명시한 주소에 있을 값의 타입과 실제로 있는 값의 타입이 다른 경우

	// 타입 불일치: 어쩔수없이 이런 경우가 있음
	//__int64* ptr2 = &number; 오류 표시가 뜸, number는 int인데 ptr2에 longlong을 원하니까 뭔가 이상하데
	//__int64 *ptr2 = (__int64*)&number; // 안심 시키기
	//*ptr2 = 0x0000AABBCCDDEEFF; // 해당 주소로가면 0000aabb하고 ccddeeff로 다른 범위까지 넘어서 저장해버림



	return 0;
}

