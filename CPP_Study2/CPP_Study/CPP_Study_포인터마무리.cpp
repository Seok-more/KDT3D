// CPP_Study.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
// 프로그램 실행: <Ctrl+F5> 또는 [디버그] > [디버깅하지 않고 시작] 메뉴
// 프로그램 디버그: <F5> 키 또는 [디버그] > [디버깅 시작] 메뉴
// 시작을 위한 팁: 
//   1. [솔루션 탐색기] 창을 사용하여 파일을 추가/관리합니다.
//   2. [팀 탐색기] 창을 사용하여 소스 제어에 연결합니다.
//   3. [출력] 창을 사용하여 빌드 출력 및 기타 메시지를 확인합니다.
//   4. [오류 목록] 창을 사용하여 오류를 봅니다.
//   5. [프로젝트] > [새 항목 추가]로 이동하여 새 코드 파일을 만들거나, [프로젝트] > [기존 항목 추가]로 이동하여 기존 코드 파일을 프로젝트에 추가합니다.
//   6. 나중에 이 프로젝트를 다시 열려면 [파일] > [열기] > [프로젝트]로 이동하고 .sln 파일을 선택합니다.
#include <iostream>
using namespace std;

// 포인터 마무리

// 1) 포인터 vs 배열2
// 2) 포인터 주의사항

int& TestRef()
{
	int a = 1;
	return a;
}

int* TestPointer()
{
	int a = 1;
	return &a;
}
void TestWrong(int* ptr)
{
	int a[100] = {};
	a[99] = 0xAAAAAAAA;
	*ptr = 0x12341234; // a의 배열을 오염해버림
}


int main()
{
	// 주소를 담는 바구니
	// 진퉁은 저 멀리 어딘가에 있음
	// p는 그 곳으로 워프하는 포탈
	int* p;

	// 진짜 데이터
	// 닭장처럼 데이터의 묶음 (엄청 많고 거대함)
	int arr[10] = { 1,2,3,4,5,6,7,8 };

	p = arr; // [배열의 이름]은 배열의 시작 주소값을 가리키는 TYPE* 포인터로 변환 가능!

	// [TYPE형 1차원 배열]과 [TYPE* 형 포인터]는 완전히 호환이 된다.
	cout << p[0] << endl;
	cout << arr[0] << endl;

	cout << *p << endl; // p[0]
	cout << *arr << endl; // arr[0]
	cout << *(p + 3) << endl;
	cout << *(arr + 3) << endl;

	// ( 2차원 배열 vs 다중 포인터 )

	// [1][2][3][4] 메모리상 이렇게 저장되어있음
	int arr2[2][2] = { {1, 2}, {3, 4} }; // arr2는 배열의 시작주소를 나타내고 위처럼 저장되어있음

	// 주소2[ int ] << 4바이트
	// 주소1[ 주소2 ]  --> 그러나 지금은 주소1[1][2][3][4] 이렇게 되어있어서 에러
	// pp[ 주소1 ]
	/*
	int** pp = (int**)arr2; // 형 변환, 즉 강제로 캐스팅해보자
	cout << (**pp) << endl; // 에러 : pp[ 주소1 ] -> 주소1[ 00000001] -> 00000001을 주소로 여겨서 일로 들어가도 할당되지 않은 이상한곳
	*/

	// [1][2][3][4]
	// TYPE name[개수]

	// p2는 * 있으므로 포인터이다 -> p2[ 주소 ] -> 주소[1][2]  [3][4]
	int(*p2)[2] = arr2; // p2라는 포인터에는 주소가 있는데, 그 주소는 배열이고 2개가 있다. 
	cout << (*p2)[0] << endl; // 1
	cout << (*p2)[1] << endl; // 2
	cout << (*(p2 + 1))[0] << endl; // 3 
	cout << (*(p2 + 1))[1] << endl; // 4

	cout << p2[0][0] << endl; // 1
	cout << p2[0][1] << endl; // 2
	cout << p2[1][0] << endl; // 3
	cout << p2[1][1] << endl; // 4


	//[매개변수][RET][지역변수]  [매개변수][RET][지역변수(a)] <- 여기는 스택프레임이 끝나는 순간 쫙 사라져서 유효하지 않아짐
	int* pointer = TestPointer();

	TestWrong(pointer);



	return 0;
}


